# Refactoring with IntelliJ

## Section 1 (이해하기 힘든 이름)

- 함수, 변수, 클래스, 모듈 이름 모두 어떤 역할인지 명확히 표현해야함
- 리팩토링 기술
  - 함수 선언 변경(Change Function Declaration)
  - 변수 이름 바꾸기(Rename Variable)
  - 필드 이름 바꾸기(Rename Field)

### 함수 선언 변경하기

함수 이름 변경, 메소드 이름 변경, 매개변수 추가, 매개변수 제거, 시그니처 변경

- 함수 이름만 보고도 이해할 수 있는 함수가 좋은 이름
- 함수에 주석을 작성한 다음 주석을 함수 이름으로 만들어보자
- 매개변수는
  - 내부의 문맥을 결정
  - 의존성을 결정
  - 즉, 파라미터로 객체가 오냐 아니면 특정한 타입에 오냐에 따라 함수에서 객체를 활용하여 결과를 만드는지
  아니면, 특정 타입만을 가지고 결과를 만드는지를 결정

### 변수 이름 바꾸기

- 많이 사용되는 변수일 수록 이름이 더욱 중요
  - 람다식에서 사용하는 변수 vs 함수의 매개변수
- 여러 곳에서 쓰이는 필드 이름은 깊은 고민이 필요

### 필드 이름 바꾸기

- Record 자료 구조의 필드 이름은 전역적으로 참조될 수 있게 매우 중요
  - Java 14부터 지원
  - 특정 데이터와 관련있는 필드를 묶어 놓은 자료구조
  - 파이썬의 Dictionary, dicts
  - DTO 나 VO 같은 것들을 Record 로 볼 수 있음
    - 단 Record 는 Immutable

## Section 2 (중복 코드)

- 단점
  - 비슷한지 완전히 동일한지 주의깊게 봐야함
  - 코드 변경 시, 동일한 모든 곳의 코드를 변경해야 함
- 리팩토링 기술
  - 동일한 코드를 여러 메소드에서 사용하는 경우
    - 함수 추출(Extract Function)
  - 코드가 비슷하지만 완전히 같진 않지않은 경우
    - 코드 분리(Slide Statement)
  - 여러 하위 클래스에 동일한 코드가 있다면
    - 메소드 올리기(Pull up Method)

### 함수 추출하기

- 의도와 구현을 분리
  - 어떤 함수가 어떤 일을 하는지 명확한가?
    - 책처럼 읽히지 않는 다면 구현
    - 코드는 의도를 드러내야 한다
- 어떤 작업을 하는 코드인지 알고 함수로 분리하고 함수 이름을 명확히 표현할 수 있음
  - 코드를 읽을 때 무슨 코드인지 노력하지 않도록 하자
- 한줄짜리 메서드도 괜찮을까?
  - 의도를 드러낸다면 오히려 좋다
- 함수 내 주석은 함수를 추출하는데 있어서 좋은 단서가 될 수 있음

### 코드 정리하기

- 관련있는 코드끼리 묶여있어야 더 쉽게 이해가 가능
- 함수에서 사용하는 변수는 상단이 아닌, 해당 변수를 사용하는 코드 바로 위에 선언
- 관련있는 코드끼리 묶은 다음, 함수 추출을 통해 더 깔끔하게 분리도 가능

### 메서드 올리기

- 중복 코드는 미래에 버그를 만들어 낼 가능성이 존재
  - A에서 고쳤지만 B는 안고친 경우
- 하위 클래스에 동일한 코드가 있다면 메서드 올리기를 통해 이를 극복할 수 있음
- 비슷하지만 일부 다른 경우 `함수 매개변수화하기` 리팩토링을 적용 후 메서드 올리기 적용
- 하위 클래스에 있는 코드가 `상위 클래스가 아닌 하위 클래스 기능에 의존`한다면 `필드 올리기`를 적용한 후 메서드 올리기 적용
- 두 메서드가 비슷한 절차라면 `템플릿 메소드 패턴` 적용

## Section 3 (긴 함수)

- 짧은 함수 vs 긴 함수
  - 짧은 함수는 많은 문맥 전환(왔다 갔다)이 필요 vs 긴 함수는 이해하기 어려움
  - 과거에는 작은 함수는 많은 서브루틴으로 인한 오버헤드가 있었음
  - `작은 함수 + 좋은 이름`이라면 함수의 코드를 보지 않아도 이해할 수 있음
  - 주석 대신 함수를 만들고 `함수의 이름으로 의도를 표현`
- 리팩토링 기술
  - 기본적으로는 99%는 함수 추출하기로 해결
  - 매개변수가 많아 진다면
    - 임시 변수를 질의 함수로 변환(Replace Temp with Query)
    - 매개변수 객체 만들기(Introduce Parameter Object)
    - 객체 통째로 넘기기(Preserve Whole Object)
  - 조건문 분해하기(Decompose Conditional)로 조건문을 분리
  - 같은 조건으로 여러 Switch 문
    - 조건문을 다형성으로 변경(Replace Conditional with Polymorphism)
  - 반복문 안에 여러작업이 있어서 하나의 메소드로 추출하기 어렵다면
    - 반복문 쪼개기(Split Loop)

### 임시 변수를 질의 함수로 바꾸기

- 임시 변수를 만들어내는 표현식을 함수로 빼내자
- 변수를 이용하면 동일한 계산을 반복하는 것을 피할 수 있고 이름을 통해 의미를 부여할 수 있음
- 임시 변수를 함수로 추출한다면 긴 함수를 리팩토링 시, 전달해야하는 파라미터 갯수를 줄일 수 있음

### 매개 변수 객체 만들기

- 같은 매개변수들이 여러 메소드에서 나타난다면 그 매개변수들을 묶은 자료 구조를 만들 수 있음
  - 해당 데이터간의 관계를 명시적으로 나타낼 수 있음
  - 전달할 매개변수의 갯수를 줄일 수 있음
  - 도메인을 이해하는데 중요한 역할을 하는 클래스로 발전 가능

### 객체 통째로 넘기기

- 여러 파라미터들이 하나의 객체 또는 레코드에서 파생된 경우 객체 자체를 넘긴다
- 매개변수 목록을 줄일 수 있음
- 의존성을 고려해야 함
- 하지만 `해당 메소드의 위치가 적절하지 않을 수` 있음
  - Feature Envy

### 함수를 명령으로 바꾸기

- 함수를 독립적인 객체인 Command 로 만들어 사용 가능
  - 단점으로는 복잡도가 증가
- 커맨드 패턴
  - 부가적으로 undo 기능을 만들 수 도 있음
  - 추가적인 기능을 구현하는데 필요한 메소드를 추가 가능
  - 상속이나 템플릿을 활용 가능
  - 복잡한 메소드를 여러 메소드나 필드로 쪼갤 수 있음
- 대부분 커맨드보다는 함수를 사용하지만, 커맨드말고 다른 방법이 없는 경우에만 사용

### 조건문 분해하기

- 조건에 따라 달라지는 코드가 긴 함수로 만들어지는 경우가 존재
- 조건과 액션은 모두 의도를 표현
- 기술적으로 함수 추출하기와 동일하지만 의도만 다를 뿐

### 반복문 쪼개기

- 하나의 반복문에서 여러작업을 하는 경우가 많음
  - 따라서 해당 반복문을 수정하면, 내부의 여러 작업을 고려해야 함
- 반복문을 여러개로 쪼개면 이해하기 쉽고 수정이 용이함
- 성능적으로 bottleneck 을 발생시키지 않는다면, 우선 반복문을 각각의 작업마다 분해
  - 이후, 성능적으로 최적화를 시도할 수 있음
  - 이론적으로 O(n)은 여러개 있어도 O(n)

### 조건문을 다형성으로

- 여러 타입에 따라 다른 로직으로 처리해야하는 경우 다형성을 적용해 명확하게 분리할 수 있음
  - 반복되는 switch 문을 각기 다른 클래스를 만들어 제거
- 공통으로 사용되는 로직은 상위클래스에, 달라지는 부분만 하위클래스에
- 모든 조건문을 다형성으로 바꿔야하는건 아님!

## Section 4 (긴 매개변수 목록)

- 매개변수가 많을 수록 함수의 역할을 이해하기 어렵다
  - 함수가 한가지 일을 하는게 맞는가?
  - 불필요한 매개변수는 없나?
  - 하나의 레코드로 뭉칠수 있는 목록은 없나?(Parameter Object)
- 리팩토링 기술
  - 어떤 매개변수를 다른 매개변수를 통해 알아 낼 수 있다면
    - 매개변수를 질의 함수로 바꾸기(Replace Parameter with Query)
    - 세부적인 데이터의 여러가지 매개변수가 아닌 객체를 넘기는
      - 객체 통째로 넘기기(Preserve Whole Object)
    - 늘 같은 매개변수들이 같이 넘어 간다면
      - 매개변수 객체 만들기(Introduce Parameter Object)
    - 매개변수가 플래그로 사용된다면
      - 플래그 인수 제거하기(Remove Flag Argument)
    - 여러 함수가 일부 매개변수를 공통으로 사용한다면
      - 여러함수를 클래스로 묶기(Combine Functions into Object)
      - 매개변수를 해당 클래스의 필드로 만들기

### 매개변수를 질의 함수로 바꾸기

- 매개변수 목록은 함수의 다양성을 대변
  - 즉, 짧을수록 이해하기 좋다
- 매개변수를 통해 다른 매개변수를 알아낼 수 있다면 `중복 매개변수`라 생각할 수 있음
- 매개변수에 값을 전달하는 것은 `함수를 호출하는 쪽의 책임`
  - 매개변수를 전달할 값을 결정하는 것은 함수를 호출하는 쪽이라는 말 
  - 가능하다면 책임을 줄이고 함수 내부에서 책임지도록 노력
- 매개변수를 무조건적으로 줄이는 것이 옳은게 아님
  - 새로운 의존성이 생긴다면 고민해봐야하는 부분

### 플래그 인수 제거하기

- 함수 내부의 로직을 분기하는데 플래그를 만힝 사용
  - 하지만, 플래그를 사용한 함수는 차이를 파악하기가 어려움
- 조건문 분해하기를 활용하여 리팩토링

### 여러 함수를 클래스로 묶기

- 비슷한 매개변수 목록을 여러 곳에서 사용한다면 해당 메소드를 모아서 클래스로
- 클래스 내부로 메소드를 옮기고 필드 변수로 만들어 매개변수 목록을 줄임

## Section 5 (전역 데이터)

- 말 그대로 전역 데이터
  - public static 변수
  - 아무 곳에서나 변경 될 수 있음
  - 어떤 코드로 인해 바뀐 것인지 파악이 어려움
- 클래스 필드 변수도 비슷한 문제
- 리팩토링 기술
  - 변수 캡슐화 하기(Encapsulate variable)
    - 접근을 제어하거나 어디서 사용하는지 파악하기 용이

### 변수 캡슐화하기

- 변수를 변경하기보다 메소드를 변경하는 것이 보다 쉬운 일
  - 메소드는 점진적으로 새로운 메소드로 변경할 수 있으나, 데이터는 한번에 모두 변경해야 함
  - 즉, 데이터 구조가 아닌 메소드 구조 변경작업으로 대체
- 데이터가 사용되는 범위가 클 수록 캡슐화 하는 것이 중요
- 불변(Immutable) 데이터는 리팩토링을 적용할 필요가 없음

## Section 6 (가변 데이터)

- 데이터를 변경하다보면 예상치 못했던 결과나 해결하기 어려운 버그가 발생하기도 함
- 함수형 프로그래밍은 데이터가 변경되지 않고 복사본을 전달
  - 하지만, 자바는 데이터 변경을 허용
- 따라서, 변경되는 데이터 사용 시 리스크를 관리할 수 있는 방법을 적용하는 것이 좋음
- 리팩토링 기술
  - 변수 캡슐화하기(Encapsulate variable)
  - 변수 쪼개기(Split variable)
    - 여러 데이터를 저장하는 변수를 나눔
  - 코드 정리하기(Slide statement)
    - 데이터를 변경하는 부분을 분리하고 회피
  - 함수 추출하기(Extract Function)
    - 데이터를 변경하는 코드로부터 사이드 이펙트가 없는 코드를 분리
  - 질의 함수와 변경 함수 분리하기(Separate Query from Modifier)
  - 세터 제거하기(Remove Setting Method)
  - 파생 변수를 질의함수로 바꾸기(Replace Derived Variable with Query)
    - 계산을 통해 알아 낼 수 있는 값을 함수로 바꿈
  - 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)
    - 변수가 사용되는 범위를 제한
  - 참조를 값으로 바꾸기(Change Reference to Value)
    - 데이터 일부를 변경하기 보다는 데이터 전체를 교체

### 변수 쪼개기

- 어떤 변수가 여러번 재할당 되어도 되는 경우
  - 반복문에서 사용되는 인덱스
  - Sum 처럼 값이 누적되어야 하는 값
- 이외에 경우에 한 변수가 재할당이된다면 변수를 분리해야 더 이해하기가 좋음
  - 변수 하나당 하나의 책임
  - 상수(final)를 활용

### 질의 함수와 변경 함수 분리하기

- 눈에 띄는 사이드 이펙트가 없이 값을 조회하는 메소드는 테스트, 이동하기 쉬움
- 명령과 조회 분리 규칙
  - 값을 리턴하는 함수는 사이드 이펙트가 없어야 함
- 눈에 띄는 사이드 이펙트
  - 분명한 객체의 상태의 변화를 일으키는 경우
  - 단, 캐시 데이터의 변경은 크게 중요하지 않음

### 세터 제거하기

- 세터를 제공하는건 해당 필드가 변경될 수 있다는 걸 뜻함
- 따라서 변경이 필요없다면 세터를 제거

### 파생 변수를 질의 함수로 바꾸기

- 변경할 수 있는 데이터를 최대한 줄여야 함
- 계산해서 알아낼 수 있는 변수는 제거 가능
  - 해당 변수가 어디선가 잘못된 값으로 수정될 가능성을 제거 가능
- 계산에 필요한 데이터가 변하지 않는다면, 결과 역시 불변이기에 변수는 그대로 유지 가능

### 여러 함수를 변환 함수로 묶기

- 관련있는 여러 파생 변수를 만드는 함수가 여러 곳에서 사용된다면 `파생변수를 변환함수`를 통해 한 곳을 모은다
- 소스 데이터가 변경될 수 있는 경우 `여러 함수를 클래스로 묶기`를 사용하는 것이 적절
- 소스 데이터가 변경되지 않는 경우 위 두가지 방법을 모두 사용할 수 있지만, 변환 함수를 사용하면 불변 데이터 필드로 생성해두고 재사용이 가능

### 참조를 값으로 바꾸기

- 레퍼런스 객체 vs 값 객체
  - mutable values 의 반대
  - 값 객체는 객체가 가진 필드의 값으로 동일성을 확보
  - 값 객체는 immutable
  - 객체의 변경 내역을 다른 곳으로 전파시킨다면 레퍼런스, 그렇지 않으면 값 객체를 사용

## Section7 (뒤엉킨 변경)

- 자주 변경되어야하는 상황에 사용
  - `여러 가지 이유로 하나의 클래스를 손봐야 하는 상황`
- 소프트웨어는 변경에 유연하게 대처해야 함
  - 응집도는 높아야하고 결합도는 낮아야함
  - 즉, 비슷한 것이나 관련있는 것은 모여있어야하고 관련 없는 것들끼리는 의존성이 낮아야 함
- 어떤 한 함수 또는 클래스가 여러가지 이유에 의해 다양하게 변경, 사용되어야 할 때
  - 새로운 방식의 도입, DB 변경 등에 이유로 여러 메소드를 수정해야하는 상황
- 서로 다른 문제는 다른 모듈에서 해결
  - 모듈의 책임이 분리되어 있을 수록 다른 문제는 신경쓰지 않아도 됨
- 리팩토링 기술
  - 단계 쪼개기(Split Phase)
    - 서로 다른 문맥의 코드를 분리
  - 함수 옮기기(Move Function)
    - 적절한 모듈로 함수를 이동
  - 함수 추출하기(Extract Function)
    - 여러가지 책임이 하나의 함수에 몰려 있는 경우
  - 클래스 추출하기(Extract Class)
    - 모듈 자체가 클래스 단위라면 별도의 클래스로 분리

### 단계 쪼개기

- 서로 다른 일을 하는 코드를 각기 다른 모듈로 분리
  - 변경 시, 관련있는 것만 신경 쓸 수 있음
- 여러 작업을하는 처리과정을 다른단계로 구분
  - 전처리 -> 주요 작업 -> 후처리
- 서로 다른 데이터를 사용한다면 단계를 나누는데 중요한 단서가 됨
- 중간 데이터를 만들어 단계를 구분하고 매개변수를 줄이는데 활용 가능

### 함수 옮기기

- 관련있는 함수나 필드가 모여있어야 더 쉽게 찾고 이해하기 좋음
  - 수정해야되는 부분이 모여있어야 다른 부분을 살펴보지 않고도 수정 가능
- 함수를 옮겨야 하는 경우
  - 해당 함수가 다른 클래스에 있는 데이터(필드)를 더 많이 참조하는 경우
  - 해당 함수를 다른 클래스에서도 필요로 하는 경우
- 함수를 옮겨갈 새로운 클래스가 필요한 경우 `여러 함수를 클래스로 묵기` 또는 `클래스 추출하기` 사용
- 옮길 적당한 위치가 없다면 일단 그대로 두고 나중에 옮기도록 하자

### 클래스 추출하기

- 크래스가 다루는 책임이 많아 질수록 클래스가 커지고 무거워 짐
- 클래스르 쪼개는 기준
  - 데이터나 메소드 중 일부가 밀접한 관련이 있는 경우
  - 일부 데이터가 같이 바뀌는 경우
  - 데이터 또는 메소드 중 일부를 삭제하면 어떻게 되는지 생각
- 하위 클래스르 만을어 책임 분산 가능

## Section 8(산탄총 수술)

- `하나의 변경 사항에 대해 여러 함수 또는 클래스를 수정`해야될 때
  - Section 7 뒤엉킨 변경과 비슷하지만 반대의 상황
  - 불필요한 결집도가 높거나 응집도가 낮을 때
- 변경 사항이 여러곳에 흩어진다면 하나하나 찾아서 고쳐야하고 중요한 부분을 놓칠 수 있음
- 리팩토링 기술
  - 함수 옮기기 또는 필드 옮기기(Move Field) 
    - 변경내역을 하나의 클래스로 모음
  - 여러 함수를 클래스로 묶기(Combine Functions into Class)
  - 단계 쪼개기(Split Phase)
    - 공통으로 사용되는 함수의 결과물을 하나로 묶음
  - 함수 인라인과 클래스 인라인으로 흩어진 로직을 한곳으로 모음

### 필드 옮기기

- 필요한 데이터들이 한 곳에 모여있으면 함수의 작성이 쉬워짐
  - 반면 데이터가 흩어져있으면 함수 작성이 어려움
- 처음에는 옳은 것 같았던 설계도 향후 습득되는 지식에 따라 옳지 않다는 것을 깨달을 수 있음
- 필드를 옮기는 단서
  - 어떤 데이터를 항상 어떤 객체와 함께 전달하는 경우
  - 어떤 객체를 변경할 떄 다른 객체에 있는 필드를 변경해야하는 경우
  - 여러 객체에 동일한 필드를 수정해야하는 경우

### 함수 인라인

- `함수 추출하기의 반대`에 해당하는 리팩토링
- 언제?
  - 함수 본문이 함수 이름 보다 의도를 잘 표현하는 경우
  - 단순한 메소드 호출을 감싸는 `우회형 메소드`라면 인라인
    - 감쌈으로써 의미의 변화가 있다면 추출하는 것도 좋은 방법!
  - 함수 리팩토링을 잘못한 경우, 인라인으로 다시 하나의 함수로 만든 후 재리팩토링을 하는 경우
- 상속 구조에서 오버라이딩 하고 있는 메소드는 인라인 할 수 없음

### 클래스 인라인

- `클래스 추출하기의 반대`에 해당하는 리팩토링
- 언제?
  - 리팩토링 하는 중 클래스가 담당해야하는 역할이 빈약해지는 경우
  - 두 개의 클래스를 여러 클래스를 여러 클래스로 나누는 리팩토링을 하는 경우
    - 클래스 인라인을 적용해 두 클래스의 코드를 한 곳으로 모으고 그 다음 클래스 추출하기로 새롭게 리팩토링

## Section 9(기능 편애)

- 기능에 욕심이 생기다보니 다른 객체이 있어야 하는 기능 또한 자신의 객체에 만들어 지는 경우
- 어떤 객체에 있는 함수가 다른 객체에 있는 데이터나 함수를 더 많이 참조하는 경우가 발생
  - 다른 객체의 getter 를 여러개 사용하는 메서드
- 리팩토링 기술
  - `함수 옮기기`
  - 함수 일부분만 다른 곳의 데이터를 참조한다면 `함수 추출하기` 
- 여러 모듈을 참조한다면 가장 많이 데이터를 참조하는 곳으로 옮기거나, 함수를 여러개로 쪼개서 각 모듈로 분산
  - 데이터와 해당 데이터를 참조하는 행동을 같은 곳에 두자
- 예외적으로 데이터와 행동을 분리한 디자인 패턴을 적용 가능
  - Strategy and Visitor pattern