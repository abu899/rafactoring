# Refactoring with IntelliJ

## Section 1 (이해하기 힘든 이름)

- 함수, 변수, 클래스, 모듈 이름 모두 어떤 역할인지 명확히 표현해야함
- 리팩토링 기술
  - 함수 선언 변경(Change Function Declaration)
  - 변수 이름 바꾸기(Rename Variable)
  - 필드 이름 바꾸기(Rename Field)

### 함수 선언 변경하기

함수 이름 변경, 메소드 이름 변경, 매개변수 추가, 매개변수 제거, 시그니처 변경

- 함수 이름만 보고도 이해할 수 있는 함수가 좋은 이름
- 함수에 주석을 작성한 다음 주석을 함수 이름으로 만들어보자
- 매개변수는
  - 내부의 문맥을 결정
  - 의존성을 결정
  - 즉, 파라미터로 객체가 오냐 아니면 특정한 타입에 오냐에 따라 함수에서 객체를 활용하여 결과를 만드는지
  아니면, 특정 타입만을 가지고 결과를 만드는지를 결정

### 변수 이름 바꾸기

- 많이 사용되는 변수일 수록 이름이 더욱 중요
  - 람다식에서 사용하는 변수 vs 함수의 매개변수
- 여러 곳에서 쓰이는 필드 이름은 깊은 고민이 필요

### 필드 이름 바꾸기

- Record 자료 구조의 필드 이름은 전역적으로 참조될 수 있게 매우 중요
  - Java 14부터 지원
  - 특정 데이터와 관련있는 필드를 묶어 놓은 자료구조
  - 파이썬의 Dictionary, dicts
  - DTO 나 VO 같은 것들을 Record 로 볼 수 있음
    - 단 Record 는 Immutable

## Section 2 (중복 코드)

- 단점
  - 비슷한지 완전히 동일한지 주의깊게 봐야함
  - 코드 변경 시, 동일한 모든 곳의 코드를 변경해야 함
- 리팩토링 기술
  - 동일한 코드를 여러 메소드에서 사용하는 경우
    - 함수 추출(Extract Function)
  - 코드가 비슷하지만 완전히 같진 않지않은 경우
    - 코드 분리(Slide Statement)
  - 여러 하위 클래스에 동일한 코드가 있다면
    - 메소드 올리기(Pull up Method)

### 함수 추출하기

- 의도와 구현을 분리
  - 어떤 함수가 어떤 일을 하는지 명확한가?
    - 책처럼 읽히지 않는 다면 구현
    - 코드는 의도를 드러내야 한다
- 어떤 작업을 하는 코드인지 알고 함수로 분리하고 함수 이름을 명확히 표현할 수 있음
  - 코드를 읽을 때 무슨 코드인지 노력하지 않도록 하자
- 한줄짜리 메서드도 괜찮을까?
  - 의도를 드러낸다면 오히려 좋다
- 함수 내 주석은 함수를 추출하는데 있어서 좋은 단서가 될 수 있음

### 코드 정리하기

- 관련있는 코드끼리 묶여있어야 더 쉽게 이해가 가능
- 함수에서 사용하는 변수는 상단이 아닌, 해당 변수를 사용하는 코드 바로 위에 선언
- 관련있는 코드끼리 묶은 다음, 함수 추출을 통해 더 깔끔하게 분리도 가능

### 메서드 올리기

- 중복 코드는 미래에 버그를 만들어 낼 가능성이 존재
  - A에서 고쳤지만 B는 안고친 경우
- 하위 클래스에 동일한 코드가 있다면 메서드 올리기를 통해 이를 극복할 수 있음
- 비슷하지만 일부 다른 경우 `함수 매개변수화하기` 리팩토링을 적용 후 메서드 올리기 적용
- 하위 클래스에 있는 코드가 `상위 클래스가 아닌 하위 클래스 기능에 의존`한다면 `필드 올리기`를 적용한 후 메서드 올리기 적용
- 두 메서드가 비슷한 절차라면 `템플릿 메소드 패턴` 적용

## Section 3 (긴 함수)

- 짧은 함수 vs 긴 함수
  - 짧은 함수는 많은 문맥 전환(왔다 갔다)이 필요 vs 긴 함수는 이해하기 어려움
  - 과거에는 작은 함수는 많은 서브루틴으로 인한 오버헤드가 있었음
  - `작은 함수 + 좋은 이름`이라면 함수의 코드를 보지 않아도 이해할 수 있음
  - 주석 대신 함수를 만들고 `함수의 이름으로 의도를 표현`
- 리팩토링 기술
  - 기본적으로는 99%는 함수 추출하기로 해결
  - 매개변수가 많아 진다면
    - 임시 변수를 질의 함수로 변환(Replace Temp with Query)
    - 매개변수 객체 만들기(Introduce Parameter Object)
    - 객체 통째로 넘기기(Preserve Whole Object)
  - 조건문 분해하기(Decompose Conditional)로 조건문을 분리
  - 같은 조건으로 여러 Switch 문
    - 조건문을 다형성으로 변경(Replace Conditional with Polymorphism)
  - 반복문 안에 여러작업이 있어서 하나의 메소드로 추출하기 어렵다면
    - 반복문 쪼개기(Split Loop)

### 임시 변수를 질의 함수로 바꾸기

- 임시 변수를 만들어내는 표현식을 함수로 빼내자
- 변수를 이용하면 동일한 계산을 반복하는 것을 피할 수 있고 이름을 통해 의미를 부여할 수 있음
- 임시 변수를 함수로 추출한다면 긴 함수를 리팩토링 시, 전달해야하는 파라미터 갯수를 줄일 수 있음

### 매개 변수 객체 만들기

- 같은 매개변수들이 여러 메소드에서 나타난다면 그 매개변수들을 묶은 자료 구조를 만들 수 있음
  - 해당 데이터간의 관계를 명시적으로 나타낼 수 있음
  - 전달할 매개변수의 갯수를 줄일 수 있음
  - 도메인을 이해하는데 중요한 역할을 하는 클래스로 발전 가능

### 객체 통째로 넘기기

- 여러 파라미터들이 하나의 객체 또는 레코드에서 파생된 경우 객체 자체를 넘긴다
- 매개변수 목록을 줄일 수 있음
- 의존성을 고려해야 함
- 하지만 `해당 메소드의 위치가 적절하지 않을 수` 있음
  - Feature Envy

### 함수를 명령으로 바꾸기

- 함수를 독립적인 객체인 Command 로 만들어 사용 가능
  - 단점으로는 복잡도가 증가
- 커맨드 패턴
  - 부가적으로 undo 기능을 만들 수 도 있음
  - 추가적인 기능을 구현하는데 필요한 메소드를 추가 가능
  - 상속이나 템플릿을 활용 가능
  - 복잡한 메소드를 여러 메소드나 필드로 쪼갤 수 있음
- 대부분 커맨드보다는 함수를 사용하지만, 커맨드말고 다른 방법이 없는 경우에만 사용

### 조건문 분해하기

- 조건에 따라 달라지는 코드가 긴 함수로 만들어지는 경우가 존재
- 조건과 액션은 모두 의도를 표현
- 기술적으로 함수 추출하기와 동일하지만 의도만 다를 뿐

### 반복문 쪼개기

- 하나의 반복문에서 여러작업을 하는 경우가 많음
  - 따라서 해당 반복문을 수정하면, 내부의 여러 작업을 고려해야 함
- 반복문을 여러개로 쪼개면 이해하기 쉽고 수정이 용이함
- 성능적으로 bottleneck 을 발생시키지 않는다면, 우선 반복문을 각각의 작업마다 분해
  - 이후, 성능적으로 최적화를 시도할 수 있음
  - 이론적으로 O(n)은 여러개 있어도 O(n)

### 조건문을 다형성으로

- 여러 타입에 따라 다른 로직으로 처리해야하는 경우 다형성을 적용해 명확하게 분리할 수 있음
  - 반복되는 switch 문을 각기 다른 클래스를 만들어 제거
- 공통으로 사용되는 로직은 상위클래스에, 달라지는 부분만 하위클래스에
- 모든 조건문을 다형성으로 바꿔야하는건 아님!

## Section 4 (긴 매개변수 목록)

- 매개변수가 많을 수록 함수의 역할을 이해하기 어렵다
  - 함수가 한가지 일을 하는게 맞는가?
  - 불필요한 매개변수는 없나?
  - 하나의 레코드로 뭉칠수 있는 목록은 없나?(Parameter Object)
- 리팩토링 기술
  - 어떤 매개변수를 다른 매개변수를 통해 알아 낼 수 있다면
    - 매개변수를 질의 함수로 바꾸기(Replace Parameter with Query)
    - 세부적인 데이터의 여러가지 매개변수가 아닌 객체를 넘기는
      - 객체 통째로 넘기기(Preserve Whole Object)
    - 늘 같은 매개변수들이 같이 넘어 간다면
      - 매개변수 객체 만들기(Introduce Parameter Object)
    - 매개변수가 플래그로 사용된다면
      - 플래그 인수 제거하기(Remove Flag Argument)
    - 여러 함수가 일부 매개변수를 공통으로 사용한다면
      - 여러함수를 클래스로 묶기(Combine Functions into Object)
      - 매개변수를 해당 클래스의 필드로 만들기

### 매개변수를 질의 함수로 바꾸기

- 매개변수 목록은 함수의 다양성을 대변
  - 즉, 짧을수록 이해하기 좋다
- 매개변수를 통해 다른 매개변수를 알아낼 수 있다면 `중복 매개변수`라 생각할 수 있음
- 매개변수에 값을 전달하는 것은 `함수를 호출하는 쪽의 책임`
  - 매개변수를 전달할 값을 결정하는 것은 함수를 호출하는 쪽이라는 말 
  - 가능하다면 책임을 줄이고 함수 내부에서 책임지도록 노력
- 매개변수를 무조건적으로 줄이는 것이 옳은게 아님
  - 새로운 의존성이 생긴다면 고민해봐야하는 부분

### 플래그 인수 제거하기

- 함수 내부의 로직을 분기하는데 플래그를 만힝 사용
  - 하지만, 플래그를 사용한 함수는 차이를 파악하기가 어려움
- 조건문 분해하기를 활용하여 리팩토링

### 여러 함수를 클래스로 묶기

- 비슷한 매개변수 목록을 여러 곳에서 사용한다면 해당 메소드를 모아서 클래스로
- 클래스 내부로 메소드를 옮기고 필드 변수로 만들어 매개변수 목록을 줄임

## Section 5 (전역 데이터)

- 말 그대로 전역 데이터
  - public static 변수
  - 아무 곳에서나 변경 될 수 있음
  - 어떤 코드로 인해 바뀐 것인지 파악이 어려움
- 클래스 필드 변수도 비슷한 문제
- 리팩토링 기술
  - 변수 캡슐화 하기(Encapsulate variable)
    - 접근을 제어하거나 어디서 사용하는지 파악하기 용이

### 변수 캡슐화하기

- 변수를 변경하기보다 메소드를 변경하는 것이 보다 쉬운 일
  - 메소드는 점진적으로 새로운 메소드로 변경할 수 있으나, 데이터는 한번에 모두 변경해야 함
  - 즉, 데이터 구조가 아닌 메소드 구조 변경작업으로 대체
- 데이터가 사용되는 범위가 클 수록 캡슐화 하는 것이 중요
- 불변(Immutable) 데이터는 리팩토링을 적용할 필요가 없음